/***********************************************************************
/
/  Cen & Ostriker star formation
/
************************************************************************/

#include <string.h>
#include <map>
#include <iostream>
#include <stdexcept>
#include <vector>
#include <stdio.h>
#include <math.h>
#include <iostream>
#include "hdf5.h"
#include "ErrorExceptions.h"
#include "macros_and_parameters.h"
#include "typedefs.h"
#include "global_data.h"
#include "Fluxes.h"
#include "GridList.h"
#include "ExternalBoundary.h"
#include "Grid.h"
#include "Hierarchy.h"
#include "TopGridData.h"
#include "EventHooks.h"
#include "ActiveParticle.h"
#include "h5utilities.h"

#ifdef NEW_CONFIG

#include "ParameterControl/ParameterControl.h"
extern Configuration Param;

/* Set default parameter values. */

const char config_cen_ostriker_particle_defaults[] =
"### CEN OSTRIKER STAR PARTICLE DEFAULTS ###\n"
"\n"
"Physics: {\n"
"    ActiveParticles: {\n"
"        CenOstriker: {\n"
"            OverdensityThreshold = 100; # [particles per proper cm^3]\n"
"            JeansMassCriterion   = true;\n"
"            StochasticStarFormation = false;\n"
"            UnigridVelocities    = false;\n"
"            PhysicalOverdensity  = false;\n"
"            dtDependence         = true;\n"
"            MassEfficiency       = 1;\n"
"            MinimumDynamicalTime = 1.0e6; # [years]\n"
"            MinimumStarMass = 1.0e9; # [Msun]\n"
"            MassEjectionFraction = 0.25;\n"
"            FeedbackDistTotalCells = 1;\n"
"            FeedbackDistRadius     = 0;\n"
"            FeedbackDistCellStep   = 0;\n"
"            EnergyToThermalFeedback = 1.0e-5;\n"
"            MetalYield              = 0.02;\n"
"        };\n"
"    };\n"
"};\n";

#endif

/* We need to make sure that we can operate on the grid, so this dance is
 * necessary to make sure that grid is 'friend' to this particle type. */

class ActiveParticleType_CenOstriker;
class CenOstrikerBufferHandler;

class CenOstrikerGrid : private grid {
  friend class ActiveParticleType_CenOstriker;
};

class ActiveParticleType_CenOstriker : public ActiveParticleType
{
public:
  static int EvaluateFormation(grid *thisgrid_orig, ActiveParticleFormationData &data);
  static int EvaluateFeedback(grid *thisgrid_orig, ActiveParticleFormationData &data);
  static void DescribeSupplementalData(ActiveParticleFormationDataFlags &flags);
  static int WriteToOutput(ActiveParticleType *these_particles, int n, int GridRank, hid_t group_id);
  static int ReadFromOutput(ActiveParticleType **particles_to_read, int *n, int GridRank, hid_t group_id);
  static ParticleBufferHandler *AllocateBuffers(int NumberOfParticles);
  static int InitializeParticleType();
  ENABLED_PARTICLE_ID_ACCESSOR
  
  static float OverdensityThreshold, MassEfficiency, MinimumDynamicalTime, 
    MinimumStarMass, MassEjectionFraction, EnergyToThermalFeedback, MetalYield;

  static int FeedbackDistTotalCells, FeedbackDistRadius, FeedbackDistCellStep;

  static bool JeansMassCriterion, StochasticStarFormation, UnigridVelocities, 
    PhysicalOverdensity, dtDependence;

  float ReturnMetallicity(void) {return Metallicity; };

private:
  float Metallicity;

};

float ActiveParticleType_CenOstriker::OverdensityThreshold = FLOAT_UNDEFINED;
float ActiveParticleType_CenOstriker::MassEfficiency = FLOAT_UNDEFINED;
float ActiveParticleType_CenOstriker::MinimumDynamicalTime = FLOAT_UNDEFINED;
float ActiveParticleType_CenOstriker::MinimumStarMass = FLOAT_UNDEFINED;
float ActiveParticleType_CenOstriker::MassEjectionFraction = FLOAT_UNDEFINED;
float ActiveParticleType_CenOstriker::EnergyToThermalFeedback = FLOAT_UNDEFINED;
float ActiveParticleType_CenOstriker::MetalYield = FLOAT_UNDEFINED;

int ActiveParticleType_CenOstriker::FeedbackDistTotalCells = INT_UNDEFINED;
int ActiveParticleType_CenOstriker::FeedbackDistRadius = INT_UNDEFINED;
int ActiveParticleType_CenOstriker::FeedbackDistCellStep = INT_UNDEFINED;

bool ActiveParticleType_CenOstriker::JeansMassCriterion = true;
bool ActiveParticleType_CenOstriker::StochasticStarFormation = false;
bool ActiveParticleType_CenOstriker::UnigridVelocities = false;
bool ActiveParticleType_CenOstriker::PhysicalOverdensity = false;
bool ActiveParticleType_CenOstriker::dtDependence = true;

int ActiveParticleType_CenOstriker::InitializeParticleType() {

#ifdef NEW_CONFIG
  
  // Update the parameter config to include the local defaults.  Note
  // that this does not overwrite any values previously specified.
  Param.Update(config_cen_ostriker_particle_defaults);

  // Retrieve parameters from Param structure
  Param.GetScalar(OverdensityThreshold, "Physics.ActiveParticles.CenOstriker.OverdensityThreshold");
  Param.GetScalar(MassEfficiency, "Physics.ActiveParticles.CenOstriker.MassEfficiency");
  Param.GetScalar(MinimumDynamicalTime, "Physics.ActiveParticles.CenOstriker.MinimumDynamicalTime");
  Param.GetScalar(MinimumStarMass, "Physics.ActiveParticles.CenOstriker.MinimumStarMass");
  Param.GetScalar(MassEjectionFraction, "Physics.ActiveParticles.CenOstriker.MassEjectionFraction");
  Param.GetScalar(EnergyToThermalFeedback, "Physics.ActiveParticles.CenOstriker.EnergyToThermalFeedback");
  Param.GetScalar(MetalYield, "Physics.ActiveParticles.CenOstriker.MetalYield");
  Param.GetScalar(FeedbackDistRadius, "Physics.ActiveParticles.CenOstriker.FeedbackDistRadius");
  Param.GetScalar(FeedbackDistCellStep, "Physics.ActiveParticles.CenOstriker.FeedbackDistCellStep");
  Param.GetScalar(JeansMassCriterion, "Physics.ActiveParticles.CenOstriker.JeansMassCriterion");
  Param.GetScalar(StochasticStarFormation, "Physics.ActiveParticles.CenOstriker.StochasticStarFormation");
  Param.GetScalar(UnigridVelocities, "Physics.ActiveParticles.CenOstriker.UnigridVelocities");
  Param.GetScalar(PhysicalOverdensity, "Physics.ActiveParticles.CenOstriker.PhysicalOverdensity");

#else
  
  OverdensityThreshold = StarMakerOverDensityThreshold;
  MassEfficiency = StarMakerMassEfficiency;
  MinimumDynamicalTime = StarMakerMinimumDynamicalTime;
  MinimumStarMass = StarMakerMinimumMass;
  MassEjectionFraction = StarMassEjectionFraction;
  EnergyToThermalFeedback = StarEnergyToThermalFeedback;
  MetalYield = StarMetalYield;
  FeedbackDistRadius = StarFeedbackDistRadius;
  FeedbackDistCellStep = StarFeedbackDistCellStep;
  JeansMassCriterion = true;
  StochasticStarFormation = false;
  UnigridVelocities = true;
  PhysicalOverdensity = true;

#endif
  
  return SUCCESS;
}

int ActiveParticleType_CenOstriker::EvaluateFormation(grid *thisgrid_orig, ActiveParticleFormationData &data)
{
  CenOstrikerGrid *thisGrid =
    static_cast<CenOstrikerGrid *>(thisgrid_orig);
  
  float BaryonMass,VelocityDivergence,TotalDensity,DynamicalTime,
    IsothermalSoundSpeedSquared,JeansMass,StarFraction, RandomNumber;
  float SoundSpeedConstant = 1.3095e8;
  float mh = 1.67262171e-24;  // [g]
  float GravConst = 6.67428e-8; // [cgs]
  float SolarMass = 1.9891e33; // [g]
  int i, j, k, dim, index, offset_y, offset_z;
  int NumberOfNewParticles = 0;


  float *density = thisGrid->BaryonField[data.DensNum];
  float *velx = thisGrid->BaryonField[data.Vel1Num];
  float *vely = thisGrid->BaryonField[data.Vel2Num];
  float *velz = thisGrid->BaryonField[data.Vel3Num];

  FLOAT dx = data.LengthUnits * thisGrid->CellWidth[0][0];

  bool HasMetalField = (data.MetalNum != -1 || data.ColourNum != -1);

  int GridDimension[3] = {thisGrid->GridDimension[0],
                          thisGrid->GridDimension[1],
                          thisGrid->GridDimension[2]};

  // Pre-calculate serialized offsets for the 3D data field.  Used for
  // the divergence.
  offset_y = thisGrid->GridDimension[0];
  offset_z = thisGrid->GridDimension[0] * thisGrid->GridDimension[1];

  for (k = thisGrid->GridStartIndex[2]; k <= thisGrid->GridEndIndex[2]; k++) {
    for (j = thisGrid->GridStartIndex[1]; j <= thisGrid->GridEndIndex[1]; j++) {
      index = GRIDINDEX_NOGHOST(thisGrid->GridStartIndex[0], j, k);
      for (i = thisGrid->GridStartIndex[0]; i <= thisGrid->GridEndIndex[0]; i++, index++) {
	
	// 0. If no more room for particles, quit.
	if (data.NumberOfNewParticles >=
	    data.MaxNumberOfNewParticles)
          continue;
	
	// 1. Finest level of refinement
	if (thisGrid->BaryonField[thisGrid->NumberOfBaryonFields][index] != 0.0) 
	  continue;
	
	// 2. Density greater than threshold
	if (density[index] < StarMakerOverDensityThreshold)
	  continue;
	
	/* 3. Negative divergence: For ZEUS, the velocities are
	   face-centered, and all of the other routines have
	   cell-centered velocities. */
	
	if (HydroMethod == Zeus_Hydro) {
	  VelocityDivergence = velx[index+1] - velx[index] +
	    vely[index+offset_y] - vely[index] + 
	    velz[index+offset_z] - velz[index];
	} else {
	  VelocityDivergence = velx[index+1] - velx[index-1] + 
	    vely[index+offset_y] - vely[index-offset_y] + 
	    velz[index+offset_z] - velz[index-offset_z];
	}

	if (VelocityDivergence > 0.0) continue;

	// 4. t_cool < t_freefall (skip if T > 11000 K)
	TotalDensity = ( density[index] + data.DarkMatterDensity[index] ) * 
	  data.DensityUnits;
	DynamicalTime = sqrt(3.0 * M_PI / 32.0 / GravConst / TotalDensity) / data.TimeUnits;
	if (DynamicalTime < data.CoolingTime[index] && 
	    data.Temperature[index] > 1.1e4)
	  continue;

	// 5. Cell mass is greater than the Jeans Mass

	if (CenOstrikerJeansMassCriterion) {
	  BaryonMass = density[index] * data.DensityUnits * dx / SolarMass;
	  IsothermalSoundSpeedSquared = SoundSpeedConstant * data.Temperature[index];
	  JeansMass = M_PI / (6.0 * sqrt(density[index] * data.DensityUnits)) *
	    POW(M_PI * IsothermalSoundSpeedSquared / GravConst,1.5) / SolarMass;
	  
	  if (BaryonMass < JeansMass)
	    continue;
	}

	// 6) Check to see if star is above threshold (given in units of M_solar)

	StarFraction = min(StarMakerMassEfficiency*thisGrid->ReturnTimeStep()/DynamicalTime, 0.9);
	DynamicalTime = max(DynamicalTime, StarMakerMinimumDynamicalTime*3.156e7/data.TimeUnits);
	
	// 7) If we allow stochastic star formation, make new particles every time the unfulfilled star formation buffer
	//    exceeds the mininimum particle mass

	if (StochasticStarFormation) {
	  if (StarFraction*BaryonMass < StarMakerMinimumMass) {
	    UnfulfilledStarFormationMass += StarFraction*BaryonMass;
	    if (UnfulfilledStarFormationMass < StarMakerMinimumMass) 
	      continue;
	    StarFraction = min(StarMakerMinimumMass/BaryonMass, 0.5);
	    UnfulfilledStarFormationMass -= StarFraction*BaryonMass;
	  } 
	}

	/*
	 * ====================================================================
	 * PARTICLE CREATION
	 * ====================================================================
	 */

	ActiveParticleType_CenOstriker *np = new ActiveParticleType_CenOstriker();
	data.NewParticles[data.NumberOfNewParticles++] = np;

	np->Mass = StarFraction*density[index];
	np->type = CenOstriker;
	np->BirthTime = thisGrid->ReturnTime();
	np->DynamicalTime = DynamicalTime;


	np->pos[0] = thisGrid->CellLeftEdge[0][i] + 0.5*thisGrid->CellWidth[0][i];
	np->pos[1] = thisGrid->CellLeftEdge[1][j] + 0.5*thisGrid->CellWidth[1][j];
	np->pos[2] = thisGrid->CellLeftEdge[2][k] + 0.5*thisGrid->CellWidth[2][k];
	
	if (UnigridVelocities == false) {
	  float *tvel = thisGrid->AveragedVelocityAtCell(index,data.DensNum,data.Vel1Num);
	  
	  np->vel[0] = tvel[0];
	  np->vel[1] = tvel[1];
	  np->vel[2] = tvel[2];
	} 
	else {
	  np->vel[0] = tiny_number;
	  np->vel[1] = tiny_number;
	  np->vel[2] = tiny_number;	  
	}

	if (HasMetalField)
	  np->Metallicity = data.TotalMetals[index];
	else
	  np->Metallicity = 0.0;

	// Remove mass from grid

	density[index] = (1.0 - StarFraction)*density[index];

      }
    }
  }
  return 0.;
}

int ActiveParticleType_CenOstriker::EvaluateFeedback
(grid *thisGrid_orig, ActiveParticleFormationData &data)
{
  CenOstrikerGrid *thisGrid =
    static_cast<CenOstrikerGrid *>(thisGrid_orig);
  ActiveParticleType_CenOstriker *particles = 
    static_cast<ActiveParticleType_CenOstriker*>(*thisGrid->ActiveParticles);
  
  float *density = thisGrid->BaryonField[data.DensNum];
  float *velx = thisGrid->BaryonField[data.Vel1Num];
  float *vely = thisGrid->BaryonField[data.Vel2Num];
  float *velz = thisGrid->BaryonField[data.Vel3Num];
  float *totalenergy = thisGrid->BaryonField[data.TENum];
  float *gasenergy = thisGrid->BaryonField[data.GENum];
  float *metals = thisGrid->BaryonField[data.MetalNum];
  float dt = thisGrid->dtFixed;
  float dx = float(thisGrid->CellWidth[0][0]);
  float clight = 2.9979e10; // [cm / s]

  float xv1, xv2, ParticleBirthTime, ParticleDynamicalTimeAtBirth,
    ParticleMass, ParticleInitialMass, ParticleMetalFraction, 
    StarFormationDensityThisTimestep, SupernovaEnergyThisTimestep, 
    DensityToAddToEachCell, DensityRatio;

  float StellarMassFormedThisTimestepOnThisGrid = 0;

  FLOAT xpos, ypos, zpos;
  float xvel, yvel, zvel;

  FLOAT CurrentTime = thisGrid->Time;
  FLOAT xstart = thisGrid->CellLeftEdge[0][0];
  FLOAT ystart = thisGrid->CellLeftEdge[1][0];
  FLOAT zstart = thisGrid->CellLeftEdge[2][0];

  int npart = thisGrid->NumberOfParticles;
  int GridXSize = thisGrid->GridDimension[0];
  int GridYSize = thisGrid->GridDimension[1];
  int GridZSize = thisGrid->GridDimension[2];
  int NumberOfGhostZones = thisGrid->GridStartIndex[0];
  int GridDimension[3] = {thisGrid->GridDimension[0],
			  thisGrid->GridDimension[1],
			  thisGrid->GridDimension[2]};
  
  int n,i,j,k,ic,kc,jc,stepk,stepj,cellstep,DistIndex,index;

  for (n=0;npart-1;n++) {
    if (thisGrid->ActiveParticles[n]->ReturnType() == CenOstriker)
      continue;
  
    //xpos = thisGrid->ActiveParticles[n]->pos[0];
    xpos = particles[n].pos[0];
    ypos = particles[n].pos[1];
    zpos = particles[n].pos[2];
  
    xvel = particles[n].vel[0];
    yvel = particles[n].vel[1];
    zvel = particles[n].vel[2];

    ParticleBirthTime = particles[n].BirthTime;
    ParticleDynamicalTimeAtBirth = particles[n].DynamicalTime;
    ParticleMass = particles[n].Mass;
    ParticleMetalFraction = particles[n].Metallicity;
    
    // Determine how much of a given star particle would have been
    // turned into stars during this timestep.  Then, calculate the
    // mass which should have formed during this timestep dt using the
    // integral form of the Cen & Ostriker formula.
    
    xv1 = (CurrentTime - ParticleBirthTime) / ParticleDynamicalTimeAtBirth;
    if (xv1 > 12.0) continue; // current time - creation time >> dynamical time at formation, so ignore
    
    xv2 = (CurrentTime + dt - ParticleBirthTime) / ParticleDynamicalTimeAtBirth;

    // First, calculate the initial mass of the star particle in question
    
    ParticleInitialMass = ParticleMass / 
      (1.0 - StarMassEjectionFraction * (1.0 - (1.0 + xv1)*exp(-xv1)));
    
    // Then, calculate the amount of mass that would have formed in this timestep.

    StarFormationDensityThisTimestep = ParticleInitialMass * ((1.0 + xv1)*exp(-xv1) - 
							   (1.0 + xv2)*exp(-xv2));
    
    StarFormationDensityThisTimestep = max(min(StarFormationDensityThisTimestep,ParticleMass),0.0);
      
    // Calculate 3D grid indices

    i = int((xpos - xstart)/thisGrid->CellWidth[0][0]);
    j = int((ypos - ystart)/thisGrid->CellWidth[1][0]);
    k = int((zpos - zstart)/thisGrid->CellWidth[2][0]);

    // Check bounds - if star particle is outside of this grid then give a warning and continue
    
    if (i < 0 || i > GridXSize-1 || j < 0 || j > GridYSize-1 || k < 0 || k > GridZSize-1){
      fprintf(stdout, "Particle out of grid; xind, yind, zind, level = %d, $d, $d, $d\n",i,j,k);
      continue;
    }
      
    // Calculate serial index

    index = GRIDINDEX_NOGHOST(thisGrid->GridStartIndex[0],j,k);

    // skip if very little mass if formed

    if (StarFormationDensityThisTimestep/density[index] < 1e-10 )
      continue;

    // calculate mass added to each cell

    DensityToAddToEachCell = (StarFormationDensityThisTimestep * StarMassEjectionFraction) / StarFeedbackDistTotalCells;

    // If using distributed feedback, check if particle is too close to the boundary and adjust indices accordingly

    if (StarFeedbackDistRadius > 0)
      {
	i = max(1+NumberOfGhostZones+StarFeedbackDistRadius,
		min(GridXSize - NumberOfGhostZones - StarFeedbackDistRadius,i));
	j = max(1+NumberOfGhostZones+StarFeedbackDistRadius,
		min(GridYSize - NumberOfGhostZones - StarFeedbackDistRadius,j));
	k = max(1+NumberOfGhostZones+StarFeedbackDistRadius,
		min(GridZSize - NumberOfGhostZones - StarFeedbackDistRadius,k));	
      }

    // Subtract ejected mass from particle
    
    ParticleMass -= StarFormationDensityThisTimestep*StarMassEjectionFraction;

    // Save particle mass

    particles[n].Mass = ParticleMass;

    // Record amount of star formation in this grid

    StellarMassFormedThisTimestepOnThisGrid += StarFormationDensityThisTimestep*dt*POW(dx,3);

    // Calculate supernova energy for this timestep

    SupernovaEnergyThisTimestep = StarEnergyToThermalFeedback * StarFormationDensityThisTimestep * 
      POW(clight/data.VelocityUnits,2) / StarFeedbackDistTotalCells;

#define NO_SHARE_ENERGY
#ifdef SHARE_ENERGY
    SupernovaEnergyThisTimestep *= StarFormationDensityThisTimestep*StarMassEjectionFraction / 
      (StarFormationDensityThisTimestep*StarMassEjectionFraction + ParticleInitialMAss*exp(-xv2)*(1.0+xv2));
#endif /* SHARE_ENERGY */

    // Add energy to the energy field
    for (kc = k - FeedbackDistRadius; kc > k + FeedbackDistRadius; kc++){
      stepk = fabs(kc - k);
      for (jc = j - FeedbackDistRadius; jc > j + FeedbackDistRadius; jc++){
	stepj = stepk + fabs(jc - j);
	for (ic = i - FeedbackDistRadius; ic > i + FeedbackDistRadius; ic++){
	  cellstep = stepj + fabs(ic - i);
	  DistIndex = GRIDINDEX_NOGHOST(thisGrid->GridStartIndex[0],jc,kc);
	  if (cellstep < StarFeedbackDistCellStep) {
	    DensityRatio = 1.0/(density[DistIndex] + DensityToAddToEachCell);
	    totalenergy[DistIndex] = ((totalenergy[DistIndex]*density[DistIndex]) + 
				      SupernovaEnergyThisTimestep)*DensityRatio;
	    if (DualEnergyFormalism == 1)
	      gasenergy[DistIndex] = ((gasenergy[DistIndex]*density[DistIndex]) + 
				      SupernovaEnergyThisTimestep)*DensityRatio;

	    // Metal feedback (note that in this function gas metal is a fraction
	    // (rho_metal/rho_gas) rather than a density.  The conversion has 
	    // been done in the handling routine)

	    // The "Cen Method".  This takes into account gas recycling:

	    if (data.MetalNum != -1)
	      metals[DistIndex] = (metals[DistIndex]*density[DistIndex]) +
		(StarFormationDensityThisTimestep / StarFeedbackDistTotalCells) *
		(StarMetalYield * (1.0 - ParticleMetalFraction) +
		 StarMassEjectionFraction * ParticleMetalFraction) * DensityRatio;

	    // Mass and momentum feedback

	    velx[DistIndex] = velx[DistIndex]*density[DistIndex] + DensityToAddToEachCell * xvel;
	    vely[DistIndex] = vely[DistIndex]*density[DistIndex] + DensityToAddToEachCell * yvel;
	    velz[DistIndex] = velz[DistIndex]*density[DistIndex] + DensityToAddToEachCell * zvel;
	    density[DistIndex] += DensityToAddToEachCell;
	    velx[DistIndex] /= density[DistIndex];
	    vely[DistIndex] /= density[DistIndex];
	    velz[DistIndex] /= density[DistIndex];
	      

	  }
	}
      }
    }

    
  } // end loop over particles
  
  return SUCCESS;
}

void ActiveParticleType_CenOstriker::DescribeSupplementalData(ActiveParticleFormationDataFlags &flags)
{
  flags.DarkMatterDensity = true;
  flags.CoolingTime = true;
  flags.Temperature = true;
  flags.UnitConversions = true;
  flags.DataFieldNumbers = true;
  flags.MetalField = true;
}

int ActiveParticleType_CenOstriker::ReadFromOutput(ActiveParticleType **particles_to_read, int *n, int GridRank, hid_t group_id)
{
  /* Open the subgroup within the active particle for active particles of type CenOstriker */

  hid_t CenOstrikerGroupID = H5Gopen(group_id,"CenOstriker");

  readAttribute(CenOstrikerGroupID,HDF5_INT,"number_of_active_particles_of_this_type",n);

  char *ParticlePositionLabel[] =
     {"position_x", "position_y", "position_z"};
  char *ParticleVelocityLabel[] =
     {"velocity_x", "velocity_y", "velocity_z"};

  FLOAT Position[GridRank][*n];
  float Velocity[GridRank][*n]; 
  double Mass[*n];
  float BirthTime[*n];
  float DynamicalTime[*n];
  float Metallicity[*n];
  
  int i,dim;

  hsize_t TempInt;
  TempInt = *n;
  
  for (dim = 0; dim < GridRank; dim++) {
    ReadDataset(1,&TempInt,ParticlePositionLabel[dim],
		  CenOstrikerGroupID, HDF5_FILE_PREC, (VOIDP) Position[dim]);
  }

  for (dim = 0; dim < GridRank; dim++) {
    ReadDataset(1,&TempInt,ParticleVelocityLabel[dim],
		  CenOstrikerGroupID, HDF5_FILE_REAL, (VOIDP) Velocity[dim]);
  }
  ReadDataset(1,&TempInt,"mass",CenOstrikerGroupID,HDF5_FILE_REAL,(VOIDP) Mass);
  ReadDataset(1,&TempInt,"creation_time",CenOstrikerGroupID,HDF5_FILE_REAL,(VOIDP) BirthTime);
  ReadDataset(1,&TempInt,"dynamical_time",CenOstrikerGroupID,HDF5_FILE_REAL,(VOIDP) DynamicalTime);
  ReadDataset(1,&TempInt,"metallicity_fraction",CenOstrikerGroupID,HDF5_FILE_REAL,(VOIDP) Metallicity);

  for (i = 0; i < *n; i++) {
    ActiveParticleType_CenOstriker *np = new ActiveParticleType_CenOstriker;
    particles_to_read[i] = np;
    np = new ActiveParticleType_CenOstriker();
    np->Mass = Mass[i];
    np->type = CenOstriker;
    np->BirthTime = DynamicalTime[i];
    np->Metallicity = Metallicity[i];
    for (dim = 0; dim < GridRank; dim++){
      np->pos[dim] = Position[dim][i];
      np->vel[dim] = Velocity[dim][i];
    }
  }
  return SUCCESS;
}

int ActiveParticleType_CenOstriker::WriteToOutput(ActiveParticleType *these_particles, int n, int GridRank, hid_t group_id)
{
  /* Create a new subgroup within the active particle group for active particles of type CenOstriker */

  hid_t CenOstrikerGroupID = H5Gcreate(group_id,"CenOstriker",0);

  writeScalarAttribute(CenOstrikerGroupID,HDF5_INT,"number_of_active_particles_of_this_type",&n);

  ActiveParticleType_CenOstriker *ParticlesToWrite = static_cast<ActiveParticleType_CenOstriker*>(these_particles);

  char *ParticlePositionLabel[] =
     {"position_x", "position_y", "position_z"};
  char *ParticleVelocityLabel[] =
     {"velocity_x", "velocity_y", "velocity_z"};

  /* Create temporary buffers to store particle data */

  FLOAT Position[GridRank][n];
  float Velocity[GridRank][n]; 
  double Mass[n];
  float BirthTime[n];
  float DynamicalTime[n];
  float Metallicity[n];
  
  FLOAT *pos;
  float *vel;

  int i,dim;

  hsize_t TempInt;
  TempInt = n;
    

  for (i=0;i<n;i++) {
    pos = ParticlesToWrite[i].ReturnPosition();
    vel = ParticlesToWrite[i].ReturnVelocity();
    for (dim = 0; dim < GridRank; dim++) {
      Position[dim][i] = pos[dim];
      Velocity[dim][i] = vel[dim];
    }
    Mass[i] = ParticlesToWrite[i].ReturnMass();
    BirthTime[i] = ParticlesToWrite[i].ReturnBirthTime();
    DynamicalTime[i] = ParticlesToWrite[i].ReturnDynamicalTime();
    Metallicity[i] = ParticlesToWrite[i].ReturnMetallicity();
  }

  for (dim = 0; dim < GridRank; dim++) {
    WriteDataset(1,&TempInt,ParticlePositionLabel[dim],
		  CenOstrikerGroupID, HDF5_FILE_PREC, (VOIDP) Position[dim]);
  }

  for (dim = 0; dim < GridRank; dim++) {
    WriteDataset(1,&TempInt,ParticleVelocityLabel[dim],
		  CenOstrikerGroupID, HDF5_FILE_REAL, (VOIDP) Velocity[dim]);
  }
  
  WriteDataset(1,&TempInt,"mass",CenOstrikerGroupID,HDF5_FILE_REAL,(VOIDP) Mass);
  WriteDataset(1,&TempInt,"creation_time",CenOstrikerGroupID,HDF5_FILE_REAL,(VOIDP) BirthTime);
  WriteDataset(1,&TempInt,"dynamical_time",CenOstrikerGroupID,HDF5_FILE_REAL,(VOIDP) DynamicalTime);
  WriteDataset(1,&TempInt,"metallicity_fraction",CenOstrikerGroupID,HDF5_FILE_REAL,(VOIDP) Metallicity);

  return SUCCESS;
}

class CenOstrikerBufferHandler : public ParticleBufferHandler
{
  public:
    CenOstrikerBufferHandler(int NumberOfParticles) { }
};

ParticleBufferHandler *ActiveParticleType_CenOstriker::AllocateBuffers(int NumberOfParticles)
{
    CenOstrikerBufferHandler *handler = new CenOstrikerBufferHandler(NumberOfParticles);
    return handler;
}


namespace {
  ActiveParticleType_info *CenOstrikerInfo = 
    register_ptype <ActiveParticleType_CenOstriker> ("CenOstriker");
}
