/***********************************************************************
/
/  AN EXAMPLE ACTIVE PARTICLE TYPE
/
/  written by: Matthew Turk
/  date:       May, 2011
/
/  PURPOSE:
/
************************************************************************/

#include "ActiveParticle_PopIII.h"

#ifdef NEW_CONFIG

#include "ParameterControl/ParameterControl.h"
extern Configuration Param;

/* Set default parameter values. */

const char config_popiii_particle_defaults[] = 
"### POPIII STAR PARTICLE DEFAULTS ###\n"
"\n"
"Physics: {\n"
"    ActiveParticles: {\n"
"        PopIII: {\n"
"            OverDensityThreshold = 1e6;\n"
"            MetalCriticalFraction = 1e-4;\n"
"            H2CriticalFraction = 5e-4;\n"
"            StarMass = 100;\n"
"        };\n"
"    };\n"
"};\n";

#endif


float CalculatePopIIILifetime(float Mass);

/* We need to make sure that we can operate on the grid, so this dance is
 * necessary to make sure that grid is 'friend' to this particle type. */

class PopIIIGrid : private grid {
  friend class ActiveParticleType_PopIII;
};

float ActiveParticleType_PopIII::OverDensityThreshold = FLOAT_UNDEFINED;
float ActiveParticleType_PopIII::MetalCriticalFraction = FLOAT_UNDEFINED;
float ActiveParticleType_PopIII::H2CriticalFraction = FLOAT_UNDEFINED;
float ActiveParticleType_PopIII::StarMass = FLOAT_UNDEFINED;

// get some parameters from the Param object
int ActiveParticleType_PopIII::InitializeParticleType() {

#ifdef NEW_CONFIG

  // Update the parameter config to include the local defaults. Note
  // that this does not overwrite any values previously specified.
  Param.Update(config_popiii_particle_defaults);

  // Retrieve parameters from Param structure
  Param.GetScalar(OverDensityThreshold, "Physics.ActiveParticles.PopIII.OverDensityThreshold");
  Param.GetScalar(MetalCriticalFraction, "Physics.ActiveParticles.PopIII.MetalCriticalFraction");
  Param.GetScalar(H2CriticalFraction, "Physics.ActiveParticles.PopIII.H2CriticalFraction");
  Param.GetScalar(StarMass, "Physics.ActiveParticles.PopIII.StarMass");

#else

  OverDensityThreshold = PopIIIOverDensityThreshold;
  MetalCriticalFraction = PopIIIMetalCriticalFraction;
  H2CriticalFraction = PopIIIH2CriticalFraction;
  StarMass = PopIIIStarMass;

#endif

  return SUCCESS;
}

PopIIIParticleBufferHandler::PopIIIParticleBufferHandler
(ActiveParticleType **np, int NumberOfParticles, int type, int proc) : 
  ParticleBufferHandler(np, NumberOfParticles, type, proc) 
  {
    // Any extra fields must be added to the buffer and this->ElementSizeInBytes
    int i, index;
    if (this->NumberOfBuffers > 0) {
      this->Lifetime = new float[this->NumberOfBuffers];
      for (i = 0, index=0; i < NumberOfParticles; i++)
	if (np[i]->ReturnType() == type && (np[i]->ReturnDestProcessor() == proc || proc==-1)) {
	  ActiveParticleType_PopIII* temp = static_cast<ActiveParticleType_PopIII*>(np[i]);
	  this->Lifetime[index] = temp->Lifetime;
	index++;
	}
    }
    this->CalculatePopIIIParticleElementSize();
  };


int ActiveParticleType_PopIII::EvaluateFormation
(grid *thisgrid_orig, ActiveParticleFormationData &supp_data)
{
  PopIIIGrid *tg = static_cast<PopIIIGrid *>(thisgrid_orig);

  float bmass, div, dtot, tdyn, LifetimeInYears;
  int i, j, k, dim, index, offset_y, offset_z;
  int NumberOfNewParticles = 0;

  /* Make it pretty */

  float *density = tg->BaryonField[supp_data.DensNum];
  float *velx = tg->BaryonField[supp_data.Vel1Num];
  float *vely = tg->BaryonField[supp_data.Vel2Num];
  float *velz = tg->BaryonField[supp_data.Vel3Num];

  bool HasMetalField = (supp_data.MetalNum != -1 ||
			supp_data.ColourNum != -1);

  int GridDimension[3] = {tg->GridDimension[0],
                          tg->GridDimension[1],
                          tg->GridDimension[2]};

  // Pre-calculate serialized offsets for the 3D data field.  Used for
  // the divergence.
  offset_y = tg->GridDimension[0];
  offset_z = tg->GridDimension[0] * tg->GridDimension[1];

  for (k = tg->GridStartIndex[2]; k <= tg->GridEndIndex[2]; k++) {
    for (j = tg->GridStartIndex[1]; j <= tg->GridEndIndex[1]; j++) {
      index = GRIDINDEX_NOGHOST(tg->GridStartIndex[0], j, k);
      for (i = tg->GridStartIndex[0]; i <= tg->GridEndIndex[0]; i++, index++) {
	
	// 0. If no more room for particles, quit.
	if (supp_data.NumberOfNewParticles >=
	    supp_data.MaxNumberOfNewParticles)
          continue;
	
	// 1. Finest level of refinement
	if (tg->BaryonField[tg->NumberOfBaryonFields][index] != 0.0) 
	  continue;
	
	// 2. Density greater than threshold
	if (density[index] < OverDensityThreshold)
	  continue;

	/* 3. Negative divergence: For ZEUS, the velocities are
	   face-centered, and all of the other routines have
	   cell-centered velocities. */

	if (HydroMethod == Zeus_Hydro) {
	  div = velx[index+1] - velx[index] +
	    vely[index+offset_y] - vely[index] + 
	    velz[index+offset_z] - velz[index];
	} else {
	  div = velx[index+1] - velx[index-1] + 
	    vely[index+offset_y] - vely[index-offset_y] + 
	    velz[index+offset_z] - velz[index-offset_z];
	}

	if (div > 0.0) continue;

	// 4. t_cool < t_freefall (skip if T > 11000 K)
	dtot = ( density[index] + supp_data.DarkMatterDensity[index] ) * 
	  supp_data.DensityUnits;
	tdyn = sqrt(3.0 * M_PI / 32.0 / GravConst / dtot) / supp_data.TimeUnits;
	if (tdyn < supp_data.CoolingTime[index] && 
	    supp_data.Temperature[index] > 1.1e4)
	  continue;

	// 5. If metallicity is greater than the critical metallicity
	if (HasMetalField && 
	    supp_data.TotalMetals[index] > MetalCriticalFraction)
	  continue;

	// 6. Require some H2 fraction to form a metal-free star
	if (supp_data.H2Fraction[index] < H2CriticalFraction)
	  continue;

	/*
	 * ====================================================================
	 * PARTICLE CREATION
	 * ====================================================================
	 */

	/* Compute the lifetime of a Pop III star, given its mass.
	   Note for an IMF, we have to recompute this after the random
	   sampling. */

	ActiveParticleType_PopIII *np = new ActiveParticleType_PopIII();
	supp_data.NewParticles[supp_data.NumberOfNewParticles++] = np;
	//fprintf(stderr, "G_APH: Creating !\n");

	LifetimeInYears = CalculatePopIIILifetime(StarMass);

	// Mass of the star will be assigned by the accretion routines.
	if (RadiativeTransfer) {
	  np->Mass = 0.0;
	  np->Lifetime = LifetimeInYears * yr / supp_data.TimeUnits;
	} else {
	  bmass = density[index] * supp_data.MassUnits;
	  np->Mass = min(0.5 * bmass, StarMass / supp_data.MassUnits);
	  np->Lifetime = LifetimeInYears * yr / supp_data.TimeUnits;
	}

	np->type = PopIII;
	np->BirthTime = tg->Time;
	
	np->pos[0] = tg->CellLeftEdge[0][i] + 0.5*tg->CellWidth[0][i];
	np->pos[1] = tg->CellLeftEdge[1][j] + 0.5*tg->CellWidth[1][j];
	np->pos[2] = tg->CellLeftEdge[2][k] + 0.5*tg->CellWidth[2][k];

	/*
	  Star velocities averaged over multiple cells to avoid
	  "runaway star particle" phenomenon imethod = 2 is zeus,
	  otherwise PPM
	*/


	float *tvel = tg->AveragedVelocityAtCell(index, supp_data.DensNum,
						 supp_data.Vel1Num);
	np->vel[0] = tvel[0];
	np->vel[1] = tvel[1];
	np->vel[2] = tvel[2];

	/* Set the metallicity */

	if (HasMetalField)
	  np->Metallicity = supp_data.TotalMetals[index];
	else
	  np->Metallicity = 0.0;

      } // ENDFOR i
    } // ENDFOR j
  } // ENDFOR k

  return NumberOfNewParticles;
}

// Pop III feedback (done through rad. transfer and feedback spheres)
int ActiveParticleType_PopIII::EvaluateFeedback
(grid *thisgrid_orig, ActiveParticleFormationData &supp_data)
{
  return SUCCESS;
}

void ActiveParticleType_PopIII::DescribeSupplementalData
(ActiveParticleFormationDataFlags &flags)
{
  flags.DarkMatterDensity = true;
  flags.H2Fraction = true;
  flags.CoolingTime = true;
  flags.Temperature = true;
  flags.UnitConversions = true;
  flags.DataFieldNumbers = true;
  flags.MetalField = true;
}

int ActiveParticleType_PopIII::WriteToOutput(ActiveParticleType **these_particles, int n, int GridRank, hid_t group_id)
{

  return SUCCESS;
}

int ActiveParticleType_PopIII::ReadFromOutput(ActiveParticleType **&particles_to_read, int &n, int GridRank, hid_t group_id)
{


  return SUCCESS;
}

int ActiveParticleType_PopIII::SetFlaggingField(LevelHierarchyEntry *LevelArray[], int level, 
						int TopGridDims[], int PopIIIParticleID)
{
  return SUCCESS;
}

int ActiveParticleType_PopIII::BeforeEvolveLevel(HierarchyEntry *Grids[], TopGridData *MetaData,
						 int NumberOfGrids, LevelHierarchyEntry *LevelArray[], 
						 int ThisLevel, int TotalStarParticleCountPrevious[],
						 int PopIIIParticleID) {
  return SUCCESS;

}
int ActiveParticleType_PopIII::AfterEvolveLevel(HierarchyEntry *Grids[], TopGridData *MetaData,
						int NumberOfGrids, LevelHierarchyEntry *LevelArray[], 
						int ThisLevel, int TotalStarParticleCountPrevious[],
						int PopIIIParticleID) {
  return SUCCESS;

}

void PopIIIParticleBufferHandler::AllocateBuffer(ActiveParticleType **np, int NumberOfParticles, 
					       char *buffer, Eint32 total_buffer_size, int &buffer_size,
					       Eint32 &position, int type_num, int proc=-1)
{
  PopIIIParticleBufferHandler *pbuffer = new PopIIIParticleBufferHandler(np, NumberOfParticles, type_num, proc);
  pbuffer->_AllocateBuffer(buffer, total_buffer_size, buffer_size, position);
  // If any extra fields are added in the future, then they would be
  // transferred to the buffer here.
#ifdef USE_MPI
  if (pbuffer->NumberOfBuffers > 0) {
    MPI_Pack(pbuffer->Lifetime,pbuffer->NumberOfBuffers, FloatDataType, buffer, total_buffer_size,
	     &position, EnzoTopComm);
  }
#endif /* USE_MPI */
  delete pbuffer;
  return;
}

void PopIIIParticleBufferHandler::UnpackBuffer(char *mpi_buffer, int mpi_buffer_size, int NumberOfParticles,
						  ActiveParticleType **np, int &npart)
{
  int i;
  Eint32 position = 0;
  PopIIIParticleBufferHandler *pbuffer = new PopIIIParticleBufferHandler(NumberOfParticles);
  pbuffer->_UnpackBuffer(mpi_buffer, mpi_buffer_size, position);
  // If any extra fields are added in the future, then they would be
  // transferred to the buffer here.
#ifdef USE_MPI
  if (pbuffer->NumberOfBuffers > 0) {
    MPI_Unpack(mpi_buffer, mpi_buffer_size, &position, pbuffer->Lifetime,
	       pbuffer->NumberOfBuffers, FloatDataType, EnzoTopComm);
  }
#endif
  /* Convert the particle buffer into active particles */
  
  for (i = 0; i < pbuffer->NumberOfBuffers; i++)
    np[npart++] = new ActiveParticleType_PopIII(pbuffer, i);
  delete pbuffer;
  return;
}

namespace {
  ActiveParticleType_info *PopIIIInfo = 
    register_ptype <ActiveParticleType_PopIII, PopIIIParticleBufferHandler> 
    ("PopIII");
}
